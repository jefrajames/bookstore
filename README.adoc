## RestBook Demo

This projects illustrates how to use Quarkus on a basic microservice architecture.

It is made of 3 modules:

* **rest-book**: an ebook store running on port 8080
* **rest-number**: a backend service running on port 8081, called by rest-book to get ISBN numbers. To make things more fun, it makes use of reactive programming by using resteasy-reactive
* **infrastructure**: the underlying technical infrastructure.

It is inspired from Antonio Goncalvez fascicule project.

## Technical context

This demo has been developed with:

* MacOS 11.6
* OpenJDK 17.28
* Maven 3.8.2
* Quarkus 2.6.0.Final
* GraalVM 21.3.0 (required to build in native mode)
* Docker 20.10.11 
* PostgreSQL 13.2
* Jaeger 1.26
* Promotheus 2.21

Some response times are provided in this document. FYI, they have been measured on a MacBook Air M1 2020 with 16GB RAM.

## Preparing the demo
This preparation should be done before running the live demo, it consists in packaging both services books and numbers.

The packaging can be made in 2 modes:

. **JVM**: based on a traditional runable jar
. **native**: based on a binary executable generated by GraalVM. BTW, GraalVM must be installed on your laptop.

### Packaging Books
Go to the rest-book directory:
[source,]
----
cd rest-book
----

#### JVM packaging
----
mvn package
----
A runnable jar is generated at
__target/quarkus-app/quarkus-run.jar__.

#### Native packaging
[source,]
----
mvn package -Pnative
----
A binary executable is generated at __./target/rest-book-1.0-runner__. 

Warning: building a native executable is a heavy process. For instance, it takes about 4 minutes on my laptop (MacBook Air M1 2020).

### Packaging Numbers

Go to _rest-number_ directory:
[source,]
----
cd rest-number
----

#### JVM packaging
----
mvn package
----
A runnable jar is generated at
__target/quarkus-app/quarkus-run.jar__.


#### Native packaging

For the moment rest-number does not work in native mode. There are some GraalVM issues due to java-faker usage. This is under investigation.


## Starting the demo

We propose to run the demo in prod mode (vs dev mode).

### Running the infrastructure
Go to the infrastructure directory:
[source,]
----
cd infrastructure
----

The infrastructure is made of:

* PostgreSQL as database
* Promotheus as backend for metrics
* Jaeger as backend for OpenTracing.

To start it:
----
docker compose up -d
----

It may take a few minutes if the images have not been downloaded.

To check the infrastructure:
----
docker ps
----
You should see the 3 running containers: postgres, prometheus and jaegertracing.

Side note: starting the infrastructure is not needed in dev mode. Thanks to the https://quarkus.io/guides/dev-services[Dev Services], PostgreSQL is automatically started with TestContainer. BTW, Promotheus and Jaeger are not needed in dev mode.

### Stopping the infrastructure

At the end of the demo, stop the infrastructure with:
----
docker compose down
----


## Running the demos

We propose to run the demos in prod mode.

### Starting Numbers

Let's start rest-number in JVM mode:

[source,]
----
cd rest-numbers
java -jar target/quarkus-app/quarkus-run.jar
----

### Starting Books

Let's start rest-book in native mode:
[source,]
----
cd rest-books
./target/rest-book-1.0-runner
----

Tribute to Josh Long: see how beautiful the banner is!

## Demo 1: Healt Check

Check that Books is ready:
----
curl -s http://localhost:8080/q/health/ready | jq
----
There are 2 readyness probes:

. one relative to the database connection, which is automatically provided by Quarkus
. an other one which defines whether the service is open or not.

By default the application is open. This can be configured with an in-memory config source:

Let's close the service:
[source,]
----
curl -v -X 'PUT' \
  'http://localhost:8080/api/microprofile-ext/memoryconfigsource/key/app.is.open' \
  -H 'accept: */*' \
  -H 'Content-Type: text/plain' \
  -d 'false'
----
We get an HTTP 202 answer (accepted).

We can check that the service is closed:
[source,]
----
curl -s http://localhost:8080/q/health/ready | jq
----

Let's try to read a random book:
[source,curl]
----
curl -s \
  -w "\n" \
  'localhost:8080/api/books/random' | jq
----
We get a __Service currently in maintenance__ answer.


Let's reopen the service for the following demos:
[source,]
----
curl -v -X 'PUT' \
  'http://localhost:8080/api/microprofile-ext/memoryconfigsource/key/app.is.open' \
  -H 'accept: */*' \
  -H 'Content-Type: text/plain' \
  -d 'true'
----


## Demo 2: API documentation

### OpenAPI

To read the OpenAPI documentation:
[source,]
----
curl -s -w "\n" localhost:8080/q/openapi\?format=json | jq | more
----

### Swagger-UI

Use your favorite browser and go to:
----
http://localhost:8080/q/swagger-ui/
----

You can check the Book endpoint and its documentation.

The code is running in "prod" mode, where swagger-ui is disabled by default. For the sake of the demo, we have enabled it by configuration:
[source,properties]
----
# Enable Swagger UI for the demo
quarkus.swagger-ui.always-include=true
----

## Demo 3: Adding a book

Numbers is called by Books on book creation (createBook.sh):
----
curl -s -w "\n" -X POST -d '{"title":"Quarkus at TNT 2022", "author":"JF James", "yearOfPublication":"2022"}' -H "Content-Type: application/json" localhost:8080/api/books -v
----

We've got a 201 status code (Created) and a link to the created resource provided with the _Location_ header parameter.

Let's read it:
----
curl -s -w "\n" localhost:8080/api/books/1 | jq
----
Remark: adapt the index if it is not 1.

## Demo 4: Fault Tolerance
So far, so good. But what if, Numbers is out of order? Let's kill it (Ctrl^C in the running terminal) and try to create a book again:
----
curl -s -w "\n" -X POST -d '{"title":"Quarkus at TNT 2022", "author":"A. Touret", "yearOfPublication":"2022"}' -H "Content-Type: application/json" localhost:8080/api/books -v
----

Now we've got a 202 (Accepted) status code: the request has been accepted but the book has not been created, because no ISBN numbers have been provided. The book creation is in pending state.

What does it mean? In fact, we've entered a fallback mode: the book data have been stored in a file for later processing:
----
curl -s localhost:8080/api/books/pending | jq
----


## Demo 5: OpenTracing & Jaeger

Let's switch to an important topic: observability and more specifically tracing.

Connect to the Jaeger UI from your browser:
----
http://localhost:16686/
----

Jaeger is a distributed tracing system developped by Uber and donated to CNCF. It can be used for:

* Distributed context propagation
* Distributed transaction monitoring
* Root cause analysis
* Service dependency analysis
* Performance / latency optimization


By default, all REST endpoints are traced. No code is needed. You just have to add the Quarkus extension, to configure it and to run a backend system such as Jaeger (or Zipkin). 

It is also possible to annotate methods or classes with __@Traced__. This has been done for  _BookService.java_. Quarkus also been enables to trace JDBC at the risk of extreme verbosity.

OpenTracing must be configured in __application.properties__. In particular, it is possible to trace all requests or to sample them. For this demo, all requests are traced.

Under the cover, context propagation is based on a specific HTTP header __uber-trace-id__.

To vizualise your book requests from Jaeger UI, click on _Search_ and select _Book_ in the list of Service. 


## Demo 6: Metrics & Prometheus

Metrics is another aspect of observability.

By default, Quarkus provides some base and vendor metrics.

Base metrics are about the JVM (classes, threads, gc):
----
curl -s localhost:8080/q/metrics/base | more
----

Vendor metrics provides complementary technical metrics (cpu load, memory):
----
curl -s localhost:8080/q/metrics/vendor | more
----

It is also possible to add custom application metrics:
----
curl -s localhost:8080/q/metrics/application | more
----

In contrast to OpenTracing, there is no default application metric. Methods have to be explicitelly annotated to generate metrics.

Curling metrics is limited to the current values, we have no historic. Let's use Prometheus to collect metrics in a smart way. Prometheus is a metrics-based monitoring and alerting system, initially developed at SoundCloud and now hosted by the CNCF. It is internally based on Time Series Database.

Promotheus has been configured to collect metrics from rest-book and rest-number (see prometheus.yml in infrastructure/monitoring).

To check that these targets are working, go to:
[source,]
----
http://localhost:9090/targets
----
You should see book and number up. If not, you should fix the _targets_ parameters if you're not running on MacOS. 

To check a given metric, go to:
[source,]
----
http://localhost:9090/graph
----

You can select a metric and do a graph with it. We can see different kinds of metrics:

* counters: how much?
* timers: how long?

Prometheus offers a basic GUI and it is recommended to use Graphana in production.


